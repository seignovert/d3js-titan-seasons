// Generated by CoffeeScript 2.7.0
  // Orbital seasons coffeescript

// Cosine and sine of angle in degrees
var Orbit, Planet, SVG, Sun, Titan, circle, dcos, dsin, ellipse, line, text,
  slice = [].slice;

dcos = function(angle) {
  return Math.cos(angle / 180 * Math.PI);
};

dsin = function(angle) {
  return Math.sin(angle / 180 * Math.PI);
};

// Shortcuts
text = function(x, y, s) {
  return {
    'x': x,
    'y': y,
    'font-size': s
  };
};

circle = function(x, y, r) {
  return {
    'cx': x,
    'cy': y,
    'r': r
  };
};

line = function(x1, y1, x2, y2) {
  return {
    'x1': x1,
    'y1': y1,
    'x2': x2,
    'y2': y2
  };
};

ellipse = function(rx, ry, cx, cy) {
  return {
    'rx': rx,
    'ry': ry,
    'cx': cx,
    'cy': cy
  };
};

// SVG Canvas
SVG = class SVG {
  constructor(w = 900, h1 = 600) {
    this.w = w;
    this.h = h1;
    this.svg = d3.select('body').append('svg').attr({
      'width': this.w,
      'height': this.h,
      'transform': `translate(${this.w / 2}, 0)`
    }).append('g').attr({
      'transform': `translate(${this.w / 2},${this.h / 2})`
    });
  }

  addOrbit(a = 200, b = 200, rot = 0) {
    this.orbit = new Orbit(a, b, rot);
    return this.orbit.draw(this.svg);
  }

  addSun(e = 0, R = '25', color = 'yellow') {
    var ref;
    this.sun = new Sun((ref = this.orbit) != null ? ref : this.addOrbit(), e, R, color);
    return this.sun.draw(this.svg);
  }

  addTitan(Ls = 0) {
    var ref;
    this.titan = new Titan((ref = this.sun) != null ? ref : this.addSun());
    this.titan.draw(this.svg);
    return this.titan.update(Ls);
  }

  addInnerTicks() {
    var Ls, i, j, results;
    for (Ls = i = 0; i <= 360; Ls = i += 10) {
      this.sun.tick(Ls, '', 5);
    }
    results = [];
    for (Ls = j = 0; j <= 360; Ls = j += 30) {
      results.push(this.sun.tick(Ls, '', 10));
    }
    return results;
  }

  addYears(years) {
    var i, len, results, year;
    results = [];
    for (i = 0, len = years.length; i < len; i++) {
      year = years[i];
      results.push(this.sun.tick(year.Ls, year.date, -10));
    }
    return results;
  }

  addFlybys(flybys) {
    var flyby, i, len, results;
    results = [];
    for (i = 0, len = flybys.length; i < len; i++) {
      flyby = flybys[i];
      results.push(this.sun.coverage(flyby.Ls, flyby.Ls + 1, flyby.color, flyby.name, 30, 0.8, true));
    }
    return results;
  }

  addCassini(cassini) {
    var first, last;
    [first] = cassini, [last] = slice.call(cassini, -1);
    return this.sun.coverage(first.Ls, last.Ls, first.color, 'Cassini');
  }

  addJWST(jwst) {
    var first, last;
    [first] = jwst, [last] = slice.call(jwst, -1);
    return this.sun.coverage(first.Ls, last.Ls, first.color);
  }

  addDragonfly(addDragonfly) {
    var first, last;
    [first] = addDragonfly, [last] = slice.call(addDragonfly, -1);
    return this.sun.coverage(first.Ls, last.Ls, first.color, first.name);
  }

  addLegend(legend) {
    var i, leg, len, results;
    results = [];
    for (i = 0, len = legend.length; i < len; i++) {
      leg = legend[i];
      results.push(this.sun.legend(leg));
    }
    return results;
  }

};

// Orbit object
Orbit = class Orbit {
  constructor(a1 = 200, b1 = 200, rot1 = 0) {
    this.a = a1;
    this.b = b1;
    this.rot = rot1;
    this.cos_r = dcos(this.rot);
    this.sin_r = dsin(this.rot);
    this.cos_r2 = Math.pow(this.cos_r, 2);
    this.sin_r2 = Math.pow(this.sin_r, 2);
    this.inv_a2 = 1 / Math.pow(this.a, 2);
    this.inv_b2 = 1 / Math.pow(this.b, 2);
    this.attr = {
      'id': 'orbit',
      'transform': `rotate(${this.rot})`
    };
    this.ellipse = {
      'attr': ellipse(this.a, this.b, 0, 0),
      'style': {
        'fill': 'none',
        'stroke': 'black',
        'stroke-width': 1,
        'stroke-dasharray': '1,3'
      }
    };
    this.majorAxis = {
      'attr': line(this.a, 0, -this.a, 0),
      'style': {
        'stroke': 'black',
        'stroke-width': 1,
        'stroke-dasharray': '2,5'
      }
    };
  }

  // Draw the orbit with dashs
  draw(svg) {
    this.g = svg.append('g').attr(this.attr);
    this.g.append('ellipse').attr(this.ellipse.attr).style(this.ellipse.style);
    return this.g.append('line').attr(this.majorAxis.attr).style(this.majorAxis.style);
  }

  // Vertical position on the tilted ellipse
  ell_Y(X) {
    var A, B, C, D;
    A = this.sin_r2 * this.inv_a2 + this.cos_r2 * this.inv_b2;
    B = 2 * X * this.cos_r * this.sin_r * (this.inv_a2 - this.inv_b2);
    C = Math.pow(X, 2) * (this.cos_r2 * this.inv_a2 + this.sin_r2 * this.inv_b2) - 1;
    D = Math.pow(B, 2) - 4 * A * C;
    return [.5 * (-B + Math.sqrt(D)) / A, .5 * (-B - Math.sqrt(D)) / A];
  }

  // Horizontal position on the tilted ellipse
  ell_X(Y) {
    var A, B, C, D;
    A = this.cos_r2 * this.inv_a2 + this.sin_r2 * this.inv_b2;
    B = 2 * Y * this.cos_r * this.sin_r * (this.inv_a2 - this.inv_b2);
    C = Math.pow(Y, 2) * (this.sin_r2 * this.inv_a2 + this.cos_r2 * this.inv_b2) - 1;
    D = Math.pow(B, 2) - 4 * A * C;
    return [.5 * (-B + Math.sqrt(D)) / A, .5 * (-B - Math.sqrt(D)) / A];
  }

};

// Sun object
Sun = class Sun {
  constructor(orbit, e, R1 = 25, color1 = 'yellow') {
    this.orbit = orbit;
    this.R = R1;
    this.color = color1;
    this.x = e * this.orbit.a * this.orbit.cos_r;
    this.y = e * this.orbit.a * this.orbit.sin_r;
    this.attr = circle(this.x, this.y, this.R);
    this.style = {
      'fill': this.color
    };
    this.lineStyle = {
      'stroke': 'black',
      'stroke-width': 1,
      'stroke-dasharray': '1,10'
    };
    this.textStyle = {
      'text-anchor': 'middle',
      'dominant-baseline': 'central'
    };
    this.yEq = this.orbit.ell_Y(this.x);
    this.lineEq = line(this.x, this.yEq[0], this.x, this.yEq[1]);
    this.xSol = this.orbit.ell_X(this.y);
    this.lineSol = line(this.xSol[0], this.y, this.xSol[1], this.y);
  }

  // Draw the Sun location
  draw(svg) {
    this.g = svg.insert('g', '#orbit');
    this.t = this.g.append('g').attr('id', 'ticks');
    this.g.append('line').attr(this.lineEq).style(this.lineStyle);
    this.g.append('line').attr(this.lineSol).style(this.lineStyle);
    return svg.append('circle').attr('id', 'Sun').attr(this.attr).style(this.style);
  }

  // Position on the tilted ellipse at the solar longitude Ls
  Ls(angle) {
    var A, B, C, D, X, Y, c, d;
    switch (angle) {
      case 0:
        return [this.x, this.yEq[1]];
      case 180:
        return [this.x, this.yEq[0]];
      default:
        c = dcos(angle) / dsin(angle);
        d = this.y - this.x * c;
        A = Math.pow(c * this.orbit.sin_r + this.orbit.cos_r, 2) * this.orbit.inv_a2 + Math.pow(c * this.orbit.cos_r - this.orbit.sin_r, 2) * this.orbit.inv_b2;
        B = 2 * d * (this.orbit.cos_r * this.orbit.sin_r * (this.orbit.inv_a2 - this.orbit.inv_b2) + c * (this.orbit.sin_r2 * this.orbit.inv_a2 + this.orbit.cos_r2 * this.orbit.inv_b2));
        C = Math.pow(d, 2) * (this.orbit.sin_r2 * this.orbit.inv_a2 + this.orbit.cos_r2 * this.orbit.inv_b2) - 1;
        D = Math.pow(B, 2) - 4 * A * C;
        X = .5 * (-B + (angle <= 180 ? -1 : 1) * Math.sqrt(D)) / A;
        Y = X * c + d;
    }
    return [X, Y];
  }

  // Draw tick on the orbit
  tick(Ls, txt, length = 10) {
    var lx, ly, x, y;
    [x, y] = this.Ls(Ls);
    lx = length * dsin(Ls);
    ly = length * dcos(Ls);
    this.t.append('path').attr('d', `M ${x},${y} l ${lx},${ly}`).style({
      'stroke': 'black',
      'stroke-width': 1,
      'fill': 'none'
    });
    if (txt != null) {
      return this.t.append('text').attr(text(x + 2.5 * lx, y + 2.5 * ly, 10)).style(this.textStyle).text(txt);
    }
  }

  // Draw thick portion of ellipse between Ls1 and Ls2
  coverage(Ls1, Ls2, color = 'gray', name, thickness = 30, opacity = 0.3, textColor = null) {
    var a2, b2, d, rt, x1, x2, x3, x4, xt, y1, y2, y3, y4, yt;
    [x1, y1] = this.Ls(Ls1);
    [x2, y2] = this.Ls(Ls2);
    x3 = x2 + thickness * dsin(Ls2);
    y3 = y2 + thickness * dcos(Ls2);
    x4 = x1 + thickness * dsin(Ls1);
    y4 = y1 + thickness * dcos(Ls1);
    a2 = this.orbit.a - thickness;
    b2 = this.orbit.b - thickness;
    d = `M ${x1},${y1}`;
    d += `A ${this.orbit.a},${this.orbit.b} ${this.orbit.rot} 0 0 ${x2},${y2}`;
    d += `L ${x3},${y3}`;
    d += `A ${a2},${b2} ${this.orbit.rot} 0 1 ${x4},${y4} Z`;
    this.t.append('path').attr('d', d).style({
      'stroke': 'none',
      'fill': color,
      'opacity': opacity
    });
    if (name != null) {
      xt = x3 + .85 * thickness * dsin(Ls2);
      yt = y3 + .85 * thickness * dcos(Ls2);
      rt = Ls2 < 180 ? 90 - Ls2 : -90 - Ls2;
      return this.t.append('text').attr(text(xt, yt, 10)).attr('transform', `rotate(${rt},${xt},${yt})`).style({
        'fill': color
      }).style(this.textStyle).text(name);
    }
  }

  // Draw legend text
  legend(leg) {
    var r, ref, ref1, rt, st, x, xt, y, yt;
    [x, y] = this.Ls(leg.Ls);
    r = Math.sqrt(x * x + y * y);
    xt = this.x - leg.r * r * dsin(leg.Ls);
    yt = this.y - leg.r * r * dcos(leg.Ls);
    rt = (ref = leg.rot) != null ? ref : (leg.Ls < 180 ? 90 - leg.Ls : -90 - leg.Ls);
    st = (ref1 = leg.size) != null ? ref1 : 10;
    return this.t.append('text').attr(text(xt, yt, st)).attr('transform', `rotate(${rt},${xt},${    // .style( 'fill': 'red' )
yt})`).style(this.textStyle).text(leg.text);
  }

};

// Planet object
Planet = class Planet {
  constructor(sun1, R1 = 15, obl = 0, color1 = 'blue', _class = 'Planet') {
    this.sun = sun1;
    this.R = R1;
    this.obl = obl;
    this.color = color1;
    this.class = _class;
    this.pole = line(0, 2 * this.R, 0, -2 * this.R);
    this.planet = circle(0, 0, this.R);
    this.poleN = text(this.R, -2 * this.R, 12);
    this.poleS = text(-this.R, 2.5 * this.R, 12);
    this.textPole = {
      'text-anchor': 'middle'
    };
    this.planetStyle = {
      'fill': this.color
    };
    this.shadowStyle = {
      'fill': 'dimgray'
    };
    this.poleStyle = {
      'stroke': 'black',
      'stroke-width': 1,
      'fill': 'none'
    };
    this.eq = {
      'd': `M ${this.R},0 A ${this.R},${.3 * this.R} 0 0 1 -${this.R},0`
    };
  }

  // Init the planet drawing at (0,0)
  draw(svg) {
    this.l = svg.insert('path', '#orbit').attr({
      'd': this.dSun(0, 0),
      'class': this.class
    }).style('stroke', 'gray');
    this.g = svg.append('g').attr('class', this.class);
    this.g.append('text').attr(this.poleN).style(this.textPole).text('N');
    this.g.append('text').attr(this.poleS).style(this.textPole).text('S');
    this.g.append('line').attr(this.pole).attr('transform', `rotate(${this.obl})`).style(this.poleStyle);
    this.g.append('circle').attr(this.planet).style(this.planetStyle);
    this.s = this.g.append('path').attr({
      'd': this.dShadow(0),
      'class': 'shadow'
    }).style(this.shadowStyle);
    return this.g.append('path').attr(this.eq).attr('transform', `rotate(${this.obl})`).style(this.poleStyle);
  }

  // Move the position of the planet at the solar longitude Ls
  update(Ls) {
    var x, y;
    [x, y] = this.sun.Ls(Ls);
    this.g.attr('transform', `translate(${x},${y})`);
    this.l.attr({
      'd': this.dSun(x, y),
      'class': this.class
    });
    return this.s.attr({
      'd': this.dShadow(Ls)
    });
  }

  // Line from the Sun to the planet
  dSun(x, y) {
    return `M ${this.sun.x},${this.sun.y}  L ${x},${y}`;
  }

  // Casted shadow on the planet
  dShadow(Ls) {
    var h, shadow, side;
    h = this.R * Math.abs(dcos(Ls));
    side = Ls <= 180 ? '1 1' : '0 0';
    shadow = dcos(Ls) * dsin(Ls) < 0 ? '0 1' : Ls < 90 ? '0 0' : '1 0';
    return `M 0,${this.R} A ${this.R},${this.R} 0 ${side} 0,-${this.R} A  ${h},${this.R} 0 ${shadow} 0,${this.R}`;
  }

};

// Titan object
Titan = class Titan extends Planet {
  constructor(sun) {
    super(sun, 15, 26.73, 'gold', 'Titan');
  }

};
